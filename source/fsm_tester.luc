module fsm_tester (
    input clk,  // clock
    input rst,  // reset
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8],    // DIP switches on IO Shield
    output a,
    output b,
    output cin
  ) {
  
  const DIV = 26;           // regulates the speed in which the inputs are generated
  
  .clk(clk) {
    .rst(rst) {
      fsm states = {MANUAL, AUTO}; // instance of a finite state machine
      dff ctr[3+DIV];              // use a flip flop as a counter for different inputs
    }
  }
  
  always {
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    a = 0;
    b = 0;
    cin = 0;
    
    case (states.q) {
      states.MANUAL:        // manual mode: use the rightmost 3 switches to do inputs
        ctr.d = 1;          // reset the counter
        
        a = io_dip[0][1];   // DIP switch 1 controls input a
        b = io_dip[0][0];   // DIP switch 0 controls input b
        cin = io_dip[0][2]; // DIP switch 2 controls input carry-in       
        io_led[0][0] = (io_dip[0][1] ^ io_dip[0][0]) ^ io_dip[0][2];                                   // Sum
        io_led[0][1] = ((io_dip[0][1] ^ io_dip[0][0]) & io_dip[0][2]) | (io_dip[0][1] & io_dip[0][0]); // Carry-out
        if (io_button[1])         // when the center button is pressed
          states.d = states.AUTO; // switch to automatic testing
 
      states.AUTO:
        io_led[1][2-:3] = ctr.q[3+DIV-1-:3]; // set the LED output
        ctr.d = ctr.q + 1;                   // increment
        if (ctr.q == 0) {                    // overflow?
          states.d = states.MANUAL;          // automatic testing done with no error, switch back to manual mode
        }
        
    }
  }
}
